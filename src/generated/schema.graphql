### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateAnswer {
  _avg: AnswerAvgAggregateOutputType
  _count: AnswerCountAggregateOutputType
  _max: AnswerMaxAggregateOutputType
  _min: AnswerMinAggregateOutputType
  _sum: AnswerSumAggregateOutputType
}

type AggregateCompleteTest {
  _avg: CompleteTestAvgAggregateOutputType
  _count: CompleteTestCountAggregateOutputType
  _max: CompleteTestMaxAggregateOutputType
  _min: CompleteTestMinAggregateOutputType
  _sum: CompleteTestSumAggregateOutputType
}

type AggregateQuestion {
  _avg: QuestionAvgAggregateOutputType
  _count: QuestionCountAggregateOutputType
  _max: QuestionMaxAggregateOutputType
  _min: QuestionMinAggregateOutputType
  _sum: QuestionSumAggregateOutputType
}

type AggregateTest {
  _avg: TestAvgAggregateOutputType
  _count: TestCountAggregateOutputType
  _max: TestMaxAggregateOutputType
  _min: TestMinAggregateOutputType
  _sum: TestSumAggregateOutputType
}

type AggregateUser {
  _avg: UserAvgAggregateOutputType
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  _sum: UserSumAggregateOutputType
}

type Answer {
  id: Int!
  inCompleteTest: CompleteTest!
  inCompleteTestId: Int!
  isRight: Boolean!
  question: Question!
  questionId: Int!
}

type AnswerAvgAggregateOutputType {
  id: Float
  inCompleteTestId: Float
  questionId: Float
}

input AnswerAvgOrderByAggregateInput {
  id: SortOrder
  inCompleteTestId: SortOrder
  questionId: SortOrder
}

type AnswerCountAggregateOutputType {
  _all: Int!
  id: Int!
  inCompleteTestId: Int!
  isRight: Int!
  questionId: Int!
}

input AnswerCountOrderByAggregateInput {
  id: SortOrder
  inCompleteTestId: SortOrder
  isRight: SortOrder
  questionId: SortOrder
}

input AnswerCreateInput {
  inCompleteTest: CompleteTestCreateNestedOneWithoutAnswersInput!
  isRight: Boolean!
  question: QuestionCreateNestedOneWithoutCompeteAnswersInput!
}

input AnswerCreateManyInCompleteTestInput {
  id: Int
  isRight: Boolean!
  questionId: Int!
}

input AnswerCreateManyInCompleteTestInputEnvelope {
  data: AnswerCreateManyInCompleteTestInput!
  skipDuplicates: Boolean
}

input AnswerCreateManyInput {
  id: Int
  inCompleteTestId: Int!
  isRight: Boolean!
  questionId: Int!
}

input AnswerCreateManyQuestionInput {
  id: Int
  inCompleteTestId: Int!
  isRight: Boolean!
}

input AnswerCreateManyQuestionInputEnvelope {
  data: AnswerCreateManyQuestionInput!
  skipDuplicates: Boolean
}

input AnswerCreateNestedManyWithoutInCompleteTestInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutInCompleteTestInput]
  create: [AnswerCreateWithoutInCompleteTestInput]
  createMany: AnswerCreateManyInCompleteTestInputEnvelope
}

input AnswerCreateNestedManyWithoutQuestionInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput]
  create: [AnswerCreateWithoutQuestionInput]
  createMany: AnswerCreateManyQuestionInputEnvelope
}

input AnswerCreateOrConnectWithoutInCompleteTestInput {
  create: AnswerUncheckedCreateWithoutInCompleteTestInput!
  where: AnswerWhereUniqueInput!
}

input AnswerCreateOrConnectWithoutQuestionInput {
  create: AnswerUncheckedCreateWithoutQuestionInput!
  where: AnswerWhereUniqueInput!
}

input AnswerCreateWithoutInCompleteTestInput {
  isRight: Boolean!
  question: QuestionCreateNestedOneWithoutCompeteAnswersInput!
}

input AnswerCreateWithoutQuestionInput {
  inCompleteTest: CompleteTestCreateNestedOneWithoutAnswersInput!
  isRight: Boolean!
}

input AnswerListRelationFilter {
  every: AnswerWhereInput
  none: AnswerWhereInput
  some: AnswerWhereInput
}

type AnswerMaxAggregateOutputType {
  id: Int
  inCompleteTestId: Int
  isRight: Boolean
  questionId: Int
}

input AnswerMaxOrderByAggregateInput {
  id: SortOrder
  inCompleteTestId: SortOrder
  isRight: SortOrder
  questionId: SortOrder
}

type AnswerMinAggregateOutputType {
  id: Int
  inCompleteTestId: Int
  isRight: Boolean
  questionId: Int
}

input AnswerMinOrderByAggregateInput {
  id: SortOrder
  inCompleteTestId: SortOrder
  isRight: SortOrder
  questionId: SortOrder
}

input AnswerOrderByRelationAggregateInput {
  _count: SortOrder
}

input AnswerOrderByWithAggregationInput {
  _avg: AnswerAvgOrderByAggregateInput
  _count: AnswerCountOrderByAggregateInput
  _max: AnswerMaxOrderByAggregateInput
  _min: AnswerMinOrderByAggregateInput
  _sum: AnswerSumOrderByAggregateInput
  id: SortOrder
  inCompleteTestId: SortOrder
  isRight: SortOrder
  questionId: SortOrder
}

input AnswerOrderByWithRelationInput {
  id: SortOrder
  inCompleteTest: CompleteTestOrderByWithRelationInput
  inCompleteTestId: SortOrder
  isRight: SortOrder
  question: QuestionOrderByWithRelationInput
  questionId: SortOrder
}

enum AnswerScalarFieldEnum {
  id
  inCompleteTestId
  isRight
  questionId
}

input AnswerScalarWhereInput {
  AND: [AnswerScalarWhereInput]
  NOT: [AnswerScalarWhereInput]
  OR: [AnswerScalarWhereInput]
  id: IntFilter
  inCompleteTestId: IntFilter
  isRight: BoolFilter
  questionId: IntFilter
}

input AnswerScalarWhereWithAggregatesInput {
  AND: [AnswerScalarWhereWithAggregatesInput]
  NOT: [AnswerScalarWhereWithAggregatesInput]
  OR: [AnswerScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  inCompleteTestId: IntWithAggregatesFilter
  isRight: BoolWithAggregatesFilter
  questionId: IntWithAggregatesFilter
}

type AnswerSumAggregateOutputType {
  id: Int
  inCompleteTestId: Int
  questionId: Int
}

input AnswerSumOrderByAggregateInput {
  id: SortOrder
  inCompleteTestId: SortOrder
  questionId: SortOrder
}

input AnswerUncheckedCreateInput {
  id: Int
  inCompleteTestId: Int!
  isRight: Boolean!
  questionId: Int!
}

input AnswerUncheckedCreateNestedManyWithoutInCompleteTestInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutInCompleteTestInput]
  create: [AnswerCreateWithoutInCompleteTestInput]
  createMany: AnswerCreateManyInCompleteTestInputEnvelope
}

input AnswerUncheckedCreateNestedManyWithoutQuestionInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput]
  create: [AnswerCreateWithoutQuestionInput]
  createMany: AnswerCreateManyQuestionInputEnvelope
}

input AnswerUncheckedCreateWithoutInCompleteTestInput {
  id: Int
  isRight: Boolean!
  questionId: Int!
}

input AnswerUncheckedCreateWithoutQuestionInput {
  id: Int
  inCompleteTestId: Int!
  isRight: Boolean!
}

input AnswerUncheckedUpdateInput {
  id: IntFieldUpdateOperationsInput
  inCompleteTestId: IntFieldUpdateOperationsInput
  isRight: BoolFieldUpdateOperationsInput
  questionId: IntFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  inCompleteTestId: IntFieldUpdateOperationsInput
  isRight: BoolFieldUpdateOperationsInput
  questionId: IntFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyWithoutAnswersInput {
  id: IntFieldUpdateOperationsInput
  isRight: BoolFieldUpdateOperationsInput
  questionId: IntFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyWithoutCompeteAnswersInput {
  id: IntFieldUpdateOperationsInput
  inCompleteTestId: IntFieldUpdateOperationsInput
  isRight: BoolFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyWithoutInCompleteTestInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutInCompleteTestInput]
  create: [AnswerCreateWithoutInCompleteTestInput]
  createMany: AnswerCreateManyInCompleteTestInputEnvelope
  delete: [AnswerWhereUniqueInput]
  deleteMany: [AnswerScalarWhereInput]
  disconnect: [AnswerWhereUniqueInput]
  set: [AnswerWhereUniqueInput]
  update: [AnswerUpdateWithWhereUniqueWithoutInCompleteTestInput]
  updateMany: [AnswerUpdateManyWithWhereWithoutInCompleteTestInput]
  upsert: [AnswerUpsertWithWhereUniqueWithoutInCompleteTestInput]
}

input AnswerUncheckedUpdateManyWithoutQuestionInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput]
  create: [AnswerCreateWithoutQuestionInput]
  createMany: AnswerCreateManyQuestionInputEnvelope
  delete: [AnswerWhereUniqueInput]
  deleteMany: [AnswerScalarWhereInput]
  disconnect: [AnswerWhereUniqueInput]
  set: [AnswerWhereUniqueInput]
  update: [AnswerUpdateWithWhereUniqueWithoutQuestionInput]
  updateMany: [AnswerUpdateManyWithWhereWithoutQuestionInput]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuestionInput]
}

input AnswerUncheckedUpdateWithoutInCompleteTestInput {
  id: IntFieldUpdateOperationsInput
  isRight: BoolFieldUpdateOperationsInput
  questionId: IntFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateWithoutQuestionInput {
  id: IntFieldUpdateOperationsInput
  inCompleteTestId: IntFieldUpdateOperationsInput
  isRight: BoolFieldUpdateOperationsInput
}

input AnswerUpdateInput {
  inCompleteTest: CompleteTestUpdateOneRequiredWithoutAnswersInput
  isRight: BoolFieldUpdateOperationsInput
  question: QuestionUpdateOneRequiredWithoutCompeteAnswersInput
}

input AnswerUpdateManyMutationInput {
  isRight: BoolFieldUpdateOperationsInput
}

input AnswerUpdateManyWithWhereWithoutInCompleteTestInput {
  data: AnswerUncheckedUpdateManyWithoutAnswersInput!
  where: AnswerScalarWhereInput!
}

input AnswerUpdateManyWithWhereWithoutQuestionInput {
  data: AnswerUncheckedUpdateManyWithoutCompeteAnswersInput!
  where: AnswerScalarWhereInput!
}

input AnswerUpdateManyWithoutInCompleteTestInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutInCompleteTestInput]
  create: [AnswerCreateWithoutInCompleteTestInput]
  createMany: AnswerCreateManyInCompleteTestInputEnvelope
  delete: [AnswerWhereUniqueInput]
  deleteMany: [AnswerScalarWhereInput]
  disconnect: [AnswerWhereUniqueInput]
  set: [AnswerWhereUniqueInput]
  update: [AnswerUpdateWithWhereUniqueWithoutInCompleteTestInput]
  updateMany: [AnswerUpdateManyWithWhereWithoutInCompleteTestInput]
  upsert: [AnswerUpsertWithWhereUniqueWithoutInCompleteTestInput]
}

input AnswerUpdateManyWithoutQuestionInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput]
  create: [AnswerCreateWithoutQuestionInput]
  createMany: AnswerCreateManyQuestionInputEnvelope
  delete: [AnswerWhereUniqueInput]
  deleteMany: [AnswerScalarWhereInput]
  disconnect: [AnswerWhereUniqueInput]
  set: [AnswerWhereUniqueInput]
  update: [AnswerUpdateWithWhereUniqueWithoutQuestionInput]
  updateMany: [AnswerUpdateManyWithWhereWithoutQuestionInput]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuestionInput]
}

input AnswerUpdateWithWhereUniqueWithoutInCompleteTestInput {
  data: AnswerUncheckedUpdateWithoutInCompleteTestInput!
  where: AnswerWhereUniqueInput!
}

input AnswerUpdateWithWhereUniqueWithoutQuestionInput {
  data: AnswerUncheckedUpdateWithoutQuestionInput!
  where: AnswerWhereUniqueInput!
}

input AnswerUpdateWithoutInCompleteTestInput {
  isRight: BoolFieldUpdateOperationsInput
  question: QuestionUpdateOneRequiredWithoutCompeteAnswersInput
}

input AnswerUpdateWithoutQuestionInput {
  inCompleteTest: CompleteTestUpdateOneRequiredWithoutAnswersInput
  isRight: BoolFieldUpdateOperationsInput
}

input AnswerUpsertWithWhereUniqueWithoutInCompleteTestInput {
  create: AnswerUncheckedCreateWithoutInCompleteTestInput!
  update: AnswerUncheckedUpdateWithoutInCompleteTestInput!
  where: AnswerWhereUniqueInput!
}

input AnswerUpsertWithWhereUniqueWithoutQuestionInput {
  create: AnswerUncheckedCreateWithoutQuestionInput!
  update: AnswerUncheckedUpdateWithoutQuestionInput!
  where: AnswerWhereUniqueInput!
}

input AnswerWhereInput {
  AND: [AnswerWhereInput]
  NOT: [AnswerWhereInput]
  OR: [AnswerWhereInput]
  id: IntFilter
  inCompleteTest: CompleteTestWhereInput
  inCompleteTestId: IntFilter
  isRight: BoolFilter
  question: QuestionWhereInput
  questionId: IntFilter
}

input AnswerWhereUniqueInput {
  id: Int
}

type BatchPayload {
  count: Int!
}

"""BigInt custom scalar type"""
scalar BigInt

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type CompleteTest {
  _count: CompleteTestCountOutputType
  answers(cursor: AnswerWhereUniqueInput, distinct: AnswerScalarFieldEnum, orderBy: AnswerOrderByWithRelationInput, skip: Int, take: Int, where: AnswerWhereInput): [Answer!]!
  id: Int!
  rightAnswers: Int!
  user: User!
  userId: Int!
}

type CompleteTestAvgAggregateOutputType {
  id: Float
  rightAnswers: Float
  userId: Float
}

input CompleteTestAvgOrderByAggregateInput {
  id: SortOrder
  rightAnswers: SortOrder
  userId: SortOrder
}

type CompleteTestCountAggregateOutputType {
  _all: Int!
  id: Int!
  rightAnswers: Int!
  userId: Int!
}

input CompleteTestCountOrderByAggregateInput {
  id: SortOrder
  rightAnswers: SortOrder
  userId: SortOrder
}

type CompleteTestCountOutputType {
  answers: Int!
}

input CompleteTestCreateInput {
  answers: AnswerCreateNestedManyWithoutInCompleteTestInput
  rightAnswers: Int!
  user: UserCreateNestedOneWithoutCompletedTestsInput!
}

input CompleteTestCreateManyInput {
  id: Int
  rightAnswers: Int!
  userId: Int!
}

input CompleteTestCreateManyUserInput {
  id: Int
  rightAnswers: Int!
}

input CompleteTestCreateManyUserInputEnvelope {
  data: CompleteTestCreateManyUserInput!
  skipDuplicates: Boolean
}

input CompleteTestCreateNestedManyWithoutUserInput {
  connect: [CompleteTestWhereUniqueInput]
  connectOrCreate: [CompleteTestCreateOrConnectWithoutUserInput]
  create: [CompleteTestCreateWithoutUserInput]
  createMany: CompleteTestCreateManyUserInputEnvelope
}

input CompleteTestCreateNestedOneWithoutAnswersInput {
  connect: CompleteTestWhereUniqueInput
  connectOrCreate: CompleteTestCreateOrConnectWithoutAnswersInput
  create: CompleteTestUncheckedCreateWithoutAnswersInput
}

input CompleteTestCreateOrConnectWithoutAnswersInput {
  create: CompleteTestUncheckedCreateWithoutAnswersInput!
  where: CompleteTestWhereUniqueInput!
}

input CompleteTestCreateOrConnectWithoutUserInput {
  create: CompleteTestUncheckedCreateWithoutUserInput!
  where: CompleteTestWhereUniqueInput!
}

input CompleteTestCreateWithoutAnswersInput {
  rightAnswers: Int!
  user: UserCreateNestedOneWithoutCompletedTestsInput!
}

input CompleteTestCreateWithoutUserInput {
  answers: AnswerCreateNestedManyWithoutInCompleteTestInput
  rightAnswers: Int!
}

input CompleteTestListRelationFilter {
  every: CompleteTestWhereInput
  none: CompleteTestWhereInput
  some: CompleteTestWhereInput
}

type CompleteTestMaxAggregateOutputType {
  id: Int
  rightAnswers: Int
  userId: Int
}

input CompleteTestMaxOrderByAggregateInput {
  id: SortOrder
  rightAnswers: SortOrder
  userId: SortOrder
}

type CompleteTestMinAggregateOutputType {
  id: Int
  rightAnswers: Int
  userId: Int
}

input CompleteTestMinOrderByAggregateInput {
  id: SortOrder
  rightAnswers: SortOrder
  userId: SortOrder
}

input CompleteTestOrderByRelationAggregateInput {
  _count: SortOrder
}

input CompleteTestOrderByWithAggregationInput {
  _avg: CompleteTestAvgOrderByAggregateInput
  _count: CompleteTestCountOrderByAggregateInput
  _max: CompleteTestMaxOrderByAggregateInput
  _min: CompleteTestMinOrderByAggregateInput
  _sum: CompleteTestSumOrderByAggregateInput
  id: SortOrder
  rightAnswers: SortOrder
  userId: SortOrder
}

input CompleteTestOrderByWithRelationInput {
  answers: AnswerOrderByRelationAggregateInput
  id: SortOrder
  rightAnswers: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input CompleteTestRelationFilter {
  is: CompleteTestWhereInput
  isNot: CompleteTestWhereInput
}

enum CompleteTestScalarFieldEnum {
  id
  rightAnswers
  userId
}

input CompleteTestScalarWhereInput {
  AND: [CompleteTestScalarWhereInput]
  NOT: [CompleteTestScalarWhereInput]
  OR: [CompleteTestScalarWhereInput]
  id: IntFilter
  rightAnswers: IntFilter
  userId: IntFilter
}

input CompleteTestScalarWhereWithAggregatesInput {
  AND: [CompleteTestScalarWhereWithAggregatesInput]
  NOT: [CompleteTestScalarWhereWithAggregatesInput]
  OR: [CompleteTestScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  rightAnswers: IntWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type CompleteTestSumAggregateOutputType {
  id: Int
  rightAnswers: Int
  userId: Int
}

input CompleteTestSumOrderByAggregateInput {
  id: SortOrder
  rightAnswers: SortOrder
  userId: SortOrder
}

input CompleteTestUncheckedCreateInput {
  answers: AnswerUncheckedCreateNestedManyWithoutInCompleteTestInput
  id: Int
  rightAnswers: Int!
  userId: Int!
}

input CompleteTestUncheckedCreateNestedManyWithoutUserInput {
  connect: [CompleteTestWhereUniqueInput]
  connectOrCreate: [CompleteTestCreateOrConnectWithoutUserInput]
  create: [CompleteTestCreateWithoutUserInput]
  createMany: CompleteTestCreateManyUserInputEnvelope
}

input CompleteTestUncheckedCreateWithoutAnswersInput {
  id: Int
  rightAnswers: Int!
  userId: Int!
}

input CompleteTestUncheckedCreateWithoutUserInput {
  answers: AnswerUncheckedCreateNestedManyWithoutInCompleteTestInput
  id: Int
  rightAnswers: Int!
}

input CompleteTestUncheckedUpdateInput {
  answers: AnswerUncheckedUpdateManyWithoutInCompleteTestInput
  id: IntFieldUpdateOperationsInput
  rightAnswers: IntFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input CompleteTestUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  rightAnswers: IntFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input CompleteTestUncheckedUpdateManyWithoutCompletedTestsInput {
  id: IntFieldUpdateOperationsInput
  rightAnswers: IntFieldUpdateOperationsInput
}

input CompleteTestUncheckedUpdateManyWithoutUserInput {
  connect: [CompleteTestWhereUniqueInput]
  connectOrCreate: [CompleteTestCreateOrConnectWithoutUserInput]
  create: [CompleteTestCreateWithoutUserInput]
  createMany: CompleteTestCreateManyUserInputEnvelope
  delete: [CompleteTestWhereUniqueInput]
  deleteMany: [CompleteTestScalarWhereInput]
  disconnect: [CompleteTestWhereUniqueInput]
  set: [CompleteTestWhereUniqueInput]
  update: [CompleteTestUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [CompleteTestUpdateManyWithWhereWithoutUserInput]
  upsert: [CompleteTestUpsertWithWhereUniqueWithoutUserInput]
}

input CompleteTestUncheckedUpdateWithoutAnswersInput {
  id: IntFieldUpdateOperationsInput
  rightAnswers: IntFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input CompleteTestUncheckedUpdateWithoutUserInput {
  answers: AnswerUncheckedUpdateManyWithoutInCompleteTestInput
  id: IntFieldUpdateOperationsInput
  rightAnswers: IntFieldUpdateOperationsInput
}

input CompleteTestUpdateInput {
  answers: AnswerUpdateManyWithoutInCompleteTestInput
  rightAnswers: IntFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCompletedTestsInput
}

input CompleteTestUpdateManyMutationInput {
  rightAnswers: IntFieldUpdateOperationsInput
}

input CompleteTestUpdateManyWithWhereWithoutUserInput {
  data: CompleteTestUncheckedUpdateManyWithoutCompletedTestsInput!
  where: CompleteTestScalarWhereInput!
}

input CompleteTestUpdateManyWithoutUserInput {
  connect: [CompleteTestWhereUniqueInput]
  connectOrCreate: [CompleteTestCreateOrConnectWithoutUserInput]
  create: [CompleteTestCreateWithoutUserInput]
  createMany: CompleteTestCreateManyUserInputEnvelope
  delete: [CompleteTestWhereUniqueInput]
  deleteMany: [CompleteTestScalarWhereInput]
  disconnect: [CompleteTestWhereUniqueInput]
  set: [CompleteTestWhereUniqueInput]
  update: [CompleteTestUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [CompleteTestUpdateManyWithWhereWithoutUserInput]
  upsert: [CompleteTestUpsertWithWhereUniqueWithoutUserInput]
}

input CompleteTestUpdateOneRequiredWithoutAnswersInput {
  connect: CompleteTestWhereUniqueInput
  connectOrCreate: CompleteTestCreateOrConnectWithoutAnswersInput
  create: CompleteTestUncheckedCreateWithoutAnswersInput
  update: CompleteTestUncheckedUpdateWithoutAnswersInput
  upsert: CompleteTestUpsertWithoutAnswersInput
}

input CompleteTestUpdateWithWhereUniqueWithoutUserInput {
  data: CompleteTestUncheckedUpdateWithoutUserInput!
  where: CompleteTestWhereUniqueInput!
}

input CompleteTestUpdateWithoutAnswersInput {
  rightAnswers: IntFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCompletedTestsInput
}

input CompleteTestUpdateWithoutUserInput {
  answers: AnswerUpdateManyWithoutInCompleteTestInput
  rightAnswers: IntFieldUpdateOperationsInput
}

input CompleteTestUpsertWithWhereUniqueWithoutUserInput {
  create: CompleteTestUncheckedCreateWithoutUserInput!
  update: CompleteTestUncheckedUpdateWithoutUserInput!
  where: CompleteTestWhereUniqueInput!
}

input CompleteTestUpsertWithoutAnswersInput {
  create: CompleteTestUncheckedCreateWithoutAnswersInput!
  update: CompleteTestUncheckedUpdateWithoutAnswersInput!
}

input CompleteTestWhereInput {
  AND: [CompleteTestWhereInput]
  NOT: [CompleteTestWhereInput]
  OR: [CompleteTestWhereInput]
  answers: AnswerListRelationFilter
  id: IntFilter
  rightAnswers: IntFilter
  user: UserWhereInput
  userId: IntFilter
}

input CompleteTestWhereUniqueInput {
  id: Int
}

"""Date custom scalar type"""
scalar DateTime

"""Decimal custom scalar type"""
scalar Decimal

type Enum {
  fields: [String!]!
  name: String!
}

input EnumQuestionTypeFieldUpdateOperationsInput {
  set: QuestionType
}

input EnumQuestionTypeFilter {
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeFilter
  notIn: [QuestionType]
}

input EnumQuestionTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumQuestionTypeFilter
  _min: NestedEnumQuestionTypeFilter
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeWithAggregatesFilter
  notIn: [QuestionType]
}

type Field {
  create: Boolean!
  editor: Boolean!
  filter: Boolean!
  id: String!
  isId: Boolean!
  kind: KindEnum!
  list: Boolean!
  name: String!
  order: Int!
  read: Boolean!
  relationField: Boolean
  required: Boolean!
  sort: Boolean!
  title: String!
  type: String!
  unique: Boolean!
  update: Boolean!
  upload: Boolean!
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

"""Json custom scalar type"""
scalar Json

enum KindEnum {
  enum
  object
  scalar
}

type Model {
  create: Boolean!
  delete: Boolean!
  displayFields: [String!]!
  fields: [Field!]!
  id: String!
  idField: String!
  name: String!
  update: Boolean!
}

type Mutation {
  createOneAnswer(data: AnswerCreateInput!): Answer!
  createOneCompleteTest(data: CompleteTestCreateInput!): CompleteTest!
  createOneQuestion(data: QuestionCreateInput!): Question!
  createOneTest(data: TestCreateInput!): Test!
  createOneUser(data: UserCreateInput!): User!
  deleteManyAnswer(where: AnswerWhereInput): BatchPayload!
  deleteManyCompleteTest(where: CompleteTestWhereInput): BatchPayload!
  deleteManyQuestion(where: QuestionWhereInput): BatchPayload!
  deleteManyTest(where: TestWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteOneCompleteTest(where: CompleteTestWhereUniqueInput!): CompleteTest
  deleteOneQuestion(where: QuestionWhereUniqueInput!): Question
  deleteOneTest(where: TestWhereUniqueInput!): Test
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateField(data: UpdateFieldInput!, id: String!, modelId: String!): Field!
  updateManyAnswer(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  updateManyCompleteTest(data: CompleteTestUpdateManyMutationInput!, where: CompleteTestWhereInput): BatchPayload!
  updateManyQuestion(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  updateManyTest(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateModel(data: UpdateModelInput!, id: String!): Model!
  updateOneAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer!
  updateOneCompleteTest(data: CompleteTestUpdateInput!, where: CompleteTestWhereUniqueInput!): CompleteTest!
  updateOneQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question!
  updateOneTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneAnswer(create: AnswerCreateInput!, update: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer!
  upsertOneCompleteTest(create: CompleteTestCreateInput!, update: CompleteTestUpdateInput!, where: CompleteTestWhereUniqueInput!): CompleteTest!
  upsertOneQuestion(create: QuestionCreateInput!, update: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question!
  upsertOneTest(create: TestCreateInput!, update: TestUpdateInput!, where: TestWhereUniqueInput!): Test!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedEnumQuestionTypeFilter {
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeFilter
  notIn: [QuestionType]
}

input NestedEnumQuestionTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumQuestionTypeFilter
  _min: NestedEnumQuestionTypeFilter
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeWithAggregatesFilter
  notIn: [QuestionType]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateAnswer(cursor: AnswerWhereUniqueInput, orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): AggregateAnswer
  aggregateCompleteTest(cursor: CompleteTestWhereUniqueInput, orderBy: [CompleteTestOrderByWithRelationInput], skip: Int, take: Int, where: CompleteTestWhereInput): AggregateCompleteTest
  aggregateQuestion(cursor: QuestionWhereUniqueInput, orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): AggregateQuestion
  aggregateTest(cursor: TestWhereUniqueInput, orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): AggregateTest
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): AggregateUser
  findFirstAnswer(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum], orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): Answer
  findFirstCompleteTest(cursor: CompleteTestWhereUniqueInput, distinct: [CompleteTestScalarFieldEnum], orderBy: [CompleteTestOrderByWithRelationInput], skip: Int, take: Int, where: CompleteTestWhereInput): CompleteTest
  findFirstQuestion(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum], orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): Question
  findFirstTest(cursor: TestWhereUniqueInput, distinct: [TestScalarFieldEnum], orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): Test
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): User
  findManyAnswer(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum], orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): [Answer!]!
  findManyAnswerCount(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum], orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): Int!
  findManyCompleteTest(cursor: CompleteTestWhereUniqueInput, distinct: [CompleteTestScalarFieldEnum], orderBy: [CompleteTestOrderByWithRelationInput], skip: Int, take: Int, where: CompleteTestWhereInput): [CompleteTest!]!
  findManyCompleteTestCount(cursor: CompleteTestWhereUniqueInput, distinct: [CompleteTestScalarFieldEnum], orderBy: [CompleteTestOrderByWithRelationInput], skip: Int, take: Int, where: CompleteTestWhereInput): Int!
  findManyQuestion(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum], orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): [Question!]!
  findManyQuestionCount(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum], orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): Int!
  findManyTest(cursor: TestWhereUniqueInput, distinct: [TestScalarFieldEnum], orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): [Test!]!
  findManyTestCount(cursor: TestWhereUniqueInput, distinct: [TestScalarFieldEnum], orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findManyUserCount(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): Int!
  findUniqueAnswer(where: AnswerWhereUniqueInput!): Answer
  findUniqueCompleteTest(where: CompleteTestWhereUniqueInput!): CompleteTest
  findUniqueQuestion(where: QuestionWhereUniqueInput!): Question
  findUniqueTest(where: TestWhereUniqueInput!): Test
  findUniqueUser(where: UserWhereUniqueInput!): User
  getSchema: Schema!
}

enum QueryMode {
  default
  insensitive
}

type Question {
  _count: QuestionCountOutputType
  answer: String
  codeArgs: [String!]!
  competeAnswers(cursor: AnswerWhereUniqueInput, distinct: AnswerScalarFieldEnum, orderBy: AnswerOrderByWithRelationInput, skip: Int, take: Int, where: AnswerWhereInput): [Answer!]!
  expectedResult: String
  id: Int!
  options: [String!]!
  parrentTest: Test!
  parrentTestId: Int!
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

type QuestionAvgAggregateOutputType {
  id: Float
  parrentTestId: Float
  timeToComplete: Float
}

input QuestionAvgOrderByAggregateInput {
  id: SortOrder
  parrentTestId: SortOrder
  timeToComplete: SortOrder
}

type QuestionCountAggregateOutputType {
  _all: Int!
  answer: Int!
  codeArgs: Int!
  expectedResult: Int!
  id: Int!
  options: Int!
  parrentTestId: Int!
  text: Int!
  timeToComplete: Int!
  type: Int!
}

input QuestionCountOrderByAggregateInput {
  answer: SortOrder
  codeArgs: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  options: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  timeToComplete: SortOrder
  type: SortOrder
}

type QuestionCountOutputType {
  competeAnswers: Int!
}

input QuestionCreateInput {
  answer: String
  codeArgs: [String]
  competeAnswers: AnswerCreateNestedManyWithoutQuestionInput
  expectedResult: String
  options: [String]
  parrentTest: TestCreateNestedOneWithoutQuestionsInput!
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionCreateManyInput {
  answer: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  parrentTestId: Int!
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionCreateManyParrentTestInput {
  answer: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionCreateManyParrentTestInputEnvelope {
  data: QuestionCreateManyParrentTestInput!
  skipDuplicates: Boolean
}

input QuestionCreateManycodeArgsInput {
  set: String!
}

input QuestionCreateManyoptionsInput {
  set: String!
}

input QuestionCreateNestedManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
}

input QuestionCreateNestedOneWithoutCompeteAnswersInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutCompeteAnswersInput
  create: QuestionUncheckedCreateWithoutCompeteAnswersInput
}

input QuestionCreateOrConnectWithoutCompeteAnswersInput {
  create: QuestionUncheckedCreateWithoutCompeteAnswersInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateOrConnectWithoutParrentTestInput {
  create: QuestionUncheckedCreateWithoutParrentTestInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateWithoutCompeteAnswersInput {
  answer: String
  codeArgs: [String]
  expectedResult: String
  options: [String]
  parrentTest: TestCreateNestedOneWithoutQuestionsInput!
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionCreateWithoutParrentTestInput {
  answer: String
  codeArgs: [String]
  competeAnswers: AnswerCreateNestedManyWithoutQuestionInput
  expectedResult: String
  options: [String]
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionCreatecodeArgsInput {
  set: String!
}

input QuestionCreateoptionsInput {
  set: String!
}

input QuestionListRelationFilter {
  every: QuestionWhereInput
  none: QuestionWhereInput
  some: QuestionWhereInput
}

type QuestionMaxAggregateOutputType {
  answer: String
  expectedResult: String
  id: Int
  parrentTestId: Int
  text: String
  timeToComplete: Int
  type: QuestionType
}

input QuestionMaxOrderByAggregateInput {
  answer: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  timeToComplete: SortOrder
  type: SortOrder
}

type QuestionMinAggregateOutputType {
  answer: String
  expectedResult: String
  id: Int
  parrentTestId: Int
  text: String
  timeToComplete: Int
  type: QuestionType
}

input QuestionMinOrderByAggregateInput {
  answer: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  timeToComplete: SortOrder
  type: SortOrder
}

input QuestionOrderByRelationAggregateInput {
  _count: SortOrder
}

input QuestionOrderByWithAggregationInput {
  _avg: QuestionAvgOrderByAggregateInput
  _count: QuestionCountOrderByAggregateInput
  _max: QuestionMaxOrderByAggregateInput
  _min: QuestionMinOrderByAggregateInput
  _sum: QuestionSumOrderByAggregateInput
  answer: SortOrder
  codeArgs: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  options: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  timeToComplete: SortOrder
  type: SortOrder
}

input QuestionOrderByWithRelationInput {
  answer: SortOrder
  codeArgs: SortOrder
  competeAnswers: AnswerOrderByRelationAggregateInput
  expectedResult: SortOrder
  id: SortOrder
  options: SortOrder
  parrentTest: TestOrderByWithRelationInput
  parrentTestId: SortOrder
  text: SortOrder
  timeToComplete: SortOrder
  type: SortOrder
}

input QuestionRelationFilter {
  is: QuestionWhereInput
  isNot: QuestionWhereInput
}

enum QuestionScalarFieldEnum {
  answer
  codeArgs
  expectedResult
  id
  options
  parrentTestId
  text
  timeToComplete
  type
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput]
  NOT: [QuestionScalarWhereInput]
  OR: [QuestionScalarWhereInput]
  answer: StringNullableFilter
  codeArgs: StringNullableListFilter
  expectedResult: StringNullableFilter
  id: IntFilter
  options: StringNullableListFilter
  parrentTestId: IntFilter
  text: StringFilter
  timeToComplete: IntNullableFilter
  type: EnumQuestionTypeFilter
}

input QuestionScalarWhereWithAggregatesInput {
  AND: [QuestionScalarWhereWithAggregatesInput]
  NOT: [QuestionScalarWhereWithAggregatesInput]
  OR: [QuestionScalarWhereWithAggregatesInput]
  answer: StringNullableWithAggregatesFilter
  codeArgs: StringNullableListFilter
  expectedResult: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  options: StringNullableListFilter
  parrentTestId: IntWithAggregatesFilter
  text: StringWithAggregatesFilter
  timeToComplete: IntNullableWithAggregatesFilter
  type: EnumQuestionTypeWithAggregatesFilter
}

type QuestionSumAggregateOutputType {
  id: Int
  parrentTestId: Int
  timeToComplete: Int
}

input QuestionSumOrderByAggregateInput {
  id: SortOrder
  parrentTestId: SortOrder
  timeToComplete: SortOrder
}

enum QuestionType {
  codeQuestion
  textQuestion
}

input QuestionUncheckedCreateInput {
  answer: String
  codeArgs: [String]
  competeAnswers: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  expectedResult: String
  id: Int
  options: [String]
  parrentTestId: Int!
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionUncheckedCreateNestedManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
}

input QuestionUncheckedCreateWithoutCompeteAnswersInput {
  answer: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  parrentTestId: Int!
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionUncheckedCreateWithoutParrentTestInput {
  answer: String
  codeArgs: [String]
  competeAnswers: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  expectedResult: String
  id: Int
  options: [String]
  text: String!
  timeToComplete: Int
  type: QuestionType!
}

input QuestionUncheckedUpdateInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  competeAnswers: AnswerUncheckedUpdateManyWithoutQuestionInput
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  parrentTestId: IntFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateManyInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  parrentTestId: IntFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
  delete: [QuestionWhereUniqueInput]
  deleteMany: [QuestionScalarWhereInput]
  disconnect: [QuestionWhereUniqueInput]
  set: [QuestionWhereUniqueInput]
  update: [QuestionUpdateWithWhereUniqueWithoutParrentTestInput]
  updateMany: [QuestionUpdateManyWithWhereWithoutParrentTestInput]
  upsert: [QuestionUpsertWithWhereUniqueWithoutParrentTestInput]
}

input QuestionUncheckedUpdateManyWithoutQuestionsInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateWithoutCompeteAnswersInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  parrentTestId: IntFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateWithoutParrentTestInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  competeAnswers: AnswerUncheckedUpdateManyWithoutQuestionInput
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  competeAnswers: AnswerUpdateManyWithoutQuestionInput
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  parrentTest: TestUpdateOneRequiredWithoutQuestionsInput
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateManyMutationInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateManyWithWhereWithoutParrentTestInput {
  data: QuestionUncheckedUpdateManyWithoutQuestionsInput!
  where: QuestionScalarWhereInput!
}

input QuestionUpdateManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
  delete: [QuestionWhereUniqueInput]
  deleteMany: [QuestionScalarWhereInput]
  disconnect: [QuestionWhereUniqueInput]
  set: [QuestionWhereUniqueInput]
  update: [QuestionUpdateWithWhereUniqueWithoutParrentTestInput]
  updateMany: [QuestionUpdateManyWithWhereWithoutParrentTestInput]
  upsert: [QuestionUpsertWithWhereUniqueWithoutParrentTestInput]
}

input QuestionUpdateOneRequiredWithoutCompeteAnswersInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutCompeteAnswersInput
  create: QuestionUncheckedCreateWithoutCompeteAnswersInput
  update: QuestionUncheckedUpdateWithoutCompeteAnswersInput
  upsert: QuestionUpsertWithoutCompeteAnswersInput
}

input QuestionUpdateWithWhereUniqueWithoutParrentTestInput {
  data: QuestionUncheckedUpdateWithoutParrentTestInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpdateWithoutCompeteAnswersInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  parrentTest: TestUpdateOneRequiredWithoutQuestionsInput
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateWithoutParrentTestInput {
  answer: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  competeAnswers: AnswerUpdateManyWithoutQuestionInput
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  timeToComplete: NullableIntFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdatecodeArgsInput {
  push: [String]
  set: [String]
}

input QuestionUpdateoptionsInput {
  push: [String]
  set: [String]
}

input QuestionUpsertWithWhereUniqueWithoutParrentTestInput {
  create: QuestionUncheckedCreateWithoutParrentTestInput!
  update: QuestionUncheckedUpdateWithoutParrentTestInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpsertWithoutCompeteAnswersInput {
  create: QuestionUncheckedCreateWithoutCompeteAnswersInput!
  update: QuestionUncheckedUpdateWithoutCompeteAnswersInput!
}

input QuestionWhereInput {
  AND: [QuestionWhereInput]
  NOT: [QuestionWhereInput]
  OR: [QuestionWhereInput]
  answer: StringNullableFilter
  codeArgs: StringNullableListFilter
  competeAnswers: AnswerListRelationFilter
  expectedResult: StringNullableFilter
  id: IntFilter
  options: StringNullableListFilter
  parrentTest: TestWhereInput
  parrentTestId: IntFilter
  text: StringFilter
  timeToComplete: IntNullableFilter
  type: EnumQuestionTypeFilter
}

input QuestionWhereUniqueInput {
  id: Int
}

type Schema {
  enums: [Enum!]!
  models: [Model!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String]
  has: String
  hasEvery: [String]
  hasSome: [String]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

type Test {
  _count: TestCountOutputType
  id: Int!
  name: String!
  questions(cursor: QuestionWhereUniqueInput, distinct: QuestionScalarFieldEnum, orderBy: QuestionOrderByWithRelationInput, skip: Int, take: Int, where: QuestionWhereInput): [Question!]!
}

type TestAvgAggregateOutputType {
  id: Float
}

input TestAvgOrderByAggregateInput {
  id: SortOrder
}

type TestCountAggregateOutputType {
  _all: Int!
  id: Int!
  name: Int!
}

input TestCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type TestCountOutputType {
  questions: Int!
}

input TestCreateInput {
  name: String!
  questions: QuestionCreateNestedManyWithoutParrentTestInput
}

input TestCreateManyInput {
  id: Int
  name: String!
}

input TestCreateNestedOneWithoutQuestionsInput {
  connect: TestWhereUniqueInput
  connectOrCreate: TestCreateOrConnectWithoutQuestionsInput
  create: TestUncheckedCreateWithoutQuestionsInput
}

input TestCreateOrConnectWithoutQuestionsInput {
  create: TestUncheckedCreateWithoutQuestionsInput!
  where: TestWhereUniqueInput!
}

input TestCreateWithoutQuestionsInput {
  name: String!
}

type TestMaxAggregateOutputType {
  id: Int
  name: String
}

input TestMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type TestMinAggregateOutputType {
  id: Int
  name: String
}

input TestMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input TestOrderByWithAggregationInput {
  _avg: TestAvgOrderByAggregateInput
  _count: TestCountOrderByAggregateInput
  _max: TestMaxOrderByAggregateInput
  _min: TestMinOrderByAggregateInput
  _sum: TestSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input TestOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  questions: QuestionOrderByRelationAggregateInput
}

input TestRelationFilter {
  is: TestWhereInput
  isNot: TestWhereInput
}

enum TestScalarFieldEnum {
  id
  name
}

input TestScalarWhereWithAggregatesInput {
  AND: [TestScalarWhereWithAggregatesInput]
  NOT: [TestScalarWhereWithAggregatesInput]
  OR: [TestScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type TestSumAggregateOutputType {
  id: Int
}

input TestSumOrderByAggregateInput {
  id: SortOrder
}

input TestUncheckedCreateInput {
  id: Int
  name: String!
  questions: QuestionUncheckedCreateNestedManyWithoutParrentTestInput
}

input TestUncheckedCreateWithoutQuestionsInput {
  id: Int
  name: String!
}

input TestUncheckedUpdateInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUncheckedUpdateManyWithoutParrentTestInput
}

input TestUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TestUncheckedUpdateWithoutQuestionsInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TestUpdateInput {
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutParrentTestInput
}

input TestUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input TestUpdateOneRequiredWithoutQuestionsInput {
  connect: TestWhereUniqueInput
  connectOrCreate: TestCreateOrConnectWithoutQuestionsInput
  create: TestUncheckedCreateWithoutQuestionsInput
  update: TestUncheckedUpdateWithoutQuestionsInput
  upsert: TestUpsertWithoutQuestionsInput
}

input TestUpdateWithoutQuestionsInput {
  name: StringFieldUpdateOperationsInput
}

input TestUpsertWithoutQuestionsInput {
  create: TestUncheckedCreateWithoutQuestionsInput!
  update: TestUncheckedUpdateWithoutQuestionsInput!
}

input TestWhereInput {
  AND: [TestWhereInput]
  NOT: [TestWhereInput]
  OR: [TestWhereInput]
  id: IntFilter
  name: StringFilter
  questions: QuestionListRelationFilter
}

input TestWhereUniqueInput {
  id: Int
}

input UpdateFieldInput {
  create: Boolean
  editor: Boolean
  filter: Boolean
  id: String
  isId: Boolean
  kind: KindEnum
  list: Boolean
  name: String
  order: Int
  read: Boolean
  relationField: Boolean
  required: Boolean
  sort: Boolean
  title: String
  type: String
  unique: Boolean
  update: Boolean
  upload: Boolean
}

input UpdateModelInput {
  create: Boolean
  delete: Boolean
  displayFields: [String]
  fields: [UpdateFieldInput]
  idField: String
  name: String
  update: Boolean
}

type User {
  _count: UserCountOutputType
  completedTests(cursor: CompleteTestWhereUniqueInput, distinct: CompleteTestScalarFieldEnum, orderBy: CompleteTestOrderByWithRelationInput, skip: Int, take: Int, where: CompleteTestWhereInput): [CompleteTest!]!
  id: Int!
  nickname: String!
  phoneNumber: String!
}

type UserAvgAggregateOutputType {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCountAggregateOutputType {
  _all: Int!
  id: Int!
  nickname: Int!
  phoneNumber: Int!
}

input UserCountOrderByAggregateInput {
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

type UserCountOutputType {
  completedTests: Int!
}

input UserCreateInput {
  completedTests: CompleteTestCreateNestedManyWithoutUserInput
  nickname: String!
  phoneNumber: String!
}

input UserCreateManyInput {
  id: Int
  nickname: String!
  phoneNumber: String!
}

input UserCreateNestedOneWithoutCompletedTestsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCompletedTestsInput
  create: UserUncheckedCreateWithoutCompletedTestsInput
}

input UserCreateOrConnectWithoutCompletedTestsInput {
  create: UserUncheckedCreateWithoutCompletedTestsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCompletedTestsInput {
  nickname: String!
  phoneNumber: String!
}

type UserMaxAggregateOutputType {
  id: Int
  nickname: String
  phoneNumber: String
}

input UserMaxOrderByAggregateInput {
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

type UserMinAggregateOutputType {
  id: Int
  nickname: String
  phoneNumber: String
}

input UserMinOrderByAggregateInput {
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

input UserOrderByWithRelationInput {
  completedTests: CompleteTestOrderByRelationAggregateInput
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  id
  nickname
  phoneNumber
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  nickname: StringWithAggregatesFilter
  phoneNumber: StringWithAggregatesFilter
}

type UserSumAggregateOutputType {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUncheckedCreateInput {
  completedTests: CompleteTestUncheckedCreateNestedManyWithoutUserInput
  id: Int
  nickname: String!
  phoneNumber: String!
}

input UserUncheckedCreateWithoutCompletedTestsInput {
  id: Int
  nickname: String!
  phoneNumber: String!
}

input UserUncheckedUpdateInput {
  completedTests: CompleteTestUncheckedUpdateManyWithoutUserInput
  id: IntFieldUpdateOperationsInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutCompletedTestsInput {
  id: IntFieldUpdateOperationsInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpdateInput {
  completedTests: CompleteTestUpdateManyWithoutUserInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCompletedTestsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCompletedTestsInput
  create: UserUncheckedCreateWithoutCompletedTestsInput
  update: UserUncheckedUpdateWithoutCompletedTestsInput
  upsert: UserUpsertWithoutCompletedTestsInput
}

input UserUpdateWithoutCompletedTestsInput {
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutCompletedTestsInput {
  create: UserUncheckedCreateWithoutCompletedTestsInput!
  update: UserUncheckedUpdateWithoutCompletedTestsInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  completedTests: CompleteTestListRelationFilter
  id: IntFilter
  nickname: StringFilter
  phoneNumber: StringFilter
}

input UserWhereUniqueInput {
  id: Int
  nickname: String
  phoneNumber: String
}
