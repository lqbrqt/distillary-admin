### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateAnswer {
  _avg: AnswerAvgAggregateOutputType
  _count: AnswerCountAggregateOutputType
  _max: AnswerMaxAggregateOutputType
  _min: AnswerMinAggregateOutputType
  _sum: AnswerSumAggregateOutputType
}

type AggregateQuestion {
  _avg: QuestionAvgAggregateOutputType
  _count: QuestionCountAggregateOutputType
  _max: QuestionMaxAggregateOutputType
  _min: QuestionMinAggregateOutputType
  _sum: QuestionSumAggregateOutputType
}

type AggregateTest {
  _avg: TestAvgAggregateOutputType
  _count: TestCountAggregateOutputType
  _max: TestMaxAggregateOutputType
  _min: TestMinAggregateOutputType
  _sum: TestSumAggregateOutputType
}

type AggregateUser {
  _avg: UserAvgAggregateOutputType
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  _sum: UserSumAggregateOutputType
}

type Answer {
  id: Int!
  isRigth: Boolean!
  user: User!
  userId: Int!
}

type AnswerAvgAggregateOutputType {
  id: Float
  userId: Float
}

input AnswerAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type AnswerCountAggregateOutputType {
  _all: Int!
  id: Int!
  isRigth: Int!
  userId: Int!
}

input AnswerCountOrderByAggregateInput {
  id: SortOrder
  isRigth: SortOrder
  userId: SortOrder
}

input AnswerCreateInput {
  isRigth: Boolean!
  user: UserCreateNestedOneWithoutAnswersInput!
}

input AnswerCreateManyInput {
  id: Int
  isRigth: Boolean!
  userId: Int!
}

input AnswerCreateManyUserInput {
  id: Int
  isRigth: Boolean!
}

input AnswerCreateManyUserInputEnvelope {
  data: AnswerCreateManyUserInput!
  skipDuplicates: Boolean
}

input AnswerCreateNestedManyWithoutUserInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutUserInput]
  create: [AnswerCreateWithoutUserInput]
  createMany: AnswerCreateManyUserInputEnvelope
}

input AnswerCreateOrConnectWithoutUserInput {
  create: AnswerUncheckedCreateWithoutUserInput!
  where: AnswerWhereUniqueInput!
}

input AnswerCreateWithoutUserInput {
  isRigth: Boolean!
}

input AnswerListRelationFilter {
  every: AnswerWhereInput
  none: AnswerWhereInput
  some: AnswerWhereInput
}

type AnswerMaxAggregateOutputType {
  id: Int
  isRigth: Boolean
  userId: Int
}

input AnswerMaxOrderByAggregateInput {
  id: SortOrder
  isRigth: SortOrder
  userId: SortOrder
}

type AnswerMinAggregateOutputType {
  id: Int
  isRigth: Boolean
  userId: Int
}

input AnswerMinOrderByAggregateInput {
  id: SortOrder
  isRigth: SortOrder
  userId: SortOrder
}

input AnswerOrderByRelationAggregateInput {
  _count: SortOrder
}

input AnswerOrderByWithAggregationInput {
  _avg: AnswerAvgOrderByAggregateInput
  _count: AnswerCountOrderByAggregateInput
  _max: AnswerMaxOrderByAggregateInput
  _min: AnswerMinOrderByAggregateInput
  _sum: AnswerSumOrderByAggregateInput
  id: SortOrder
  isRigth: SortOrder
  userId: SortOrder
}

input AnswerOrderByWithRelationInput {
  id: SortOrder
  isRigth: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum AnswerScalarFieldEnum {
  id
  isRigth
  userId
}

input AnswerScalarWhereInput {
  AND: [AnswerScalarWhereInput]
  NOT: [AnswerScalarWhereInput]
  OR: [AnswerScalarWhereInput]
  id: IntFilter
  isRigth: BoolFilter
  userId: IntFilter
}

input AnswerScalarWhereWithAggregatesInput {
  AND: [AnswerScalarWhereWithAggregatesInput]
  NOT: [AnswerScalarWhereWithAggregatesInput]
  OR: [AnswerScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  isRigth: BoolWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AnswerSumAggregateOutputType {
  id: Int
  userId: Int
}

input AnswerSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input AnswerUncheckedCreateInput {
  id: Int
  isRigth: Boolean!
  userId: Int!
}

input AnswerUncheckedCreateNestedManyWithoutUserInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutUserInput]
  create: [AnswerCreateWithoutUserInput]
  createMany: AnswerCreateManyUserInputEnvelope
}

input AnswerUncheckedCreateWithoutUserInput {
  id: Int
  isRigth: Boolean!
}

input AnswerUncheckedUpdateInput {
  id: IntFieldUpdateOperationsInput
  isRigth: BoolFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  isRigth: BoolFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyWithoutAnswersInput {
  id: IntFieldUpdateOperationsInput
  isRigth: BoolFieldUpdateOperationsInput
}

input AnswerUncheckedUpdateManyWithoutUserInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutUserInput]
  create: [AnswerCreateWithoutUserInput]
  createMany: AnswerCreateManyUserInputEnvelope
  delete: [AnswerWhereUniqueInput]
  deleteMany: [AnswerScalarWhereInput]
  disconnect: [AnswerWhereUniqueInput]
  set: [AnswerWhereUniqueInput]
  update: [AnswerUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [AnswerUpdateManyWithWhereWithoutUserInput]
  upsert: [AnswerUpsertWithWhereUniqueWithoutUserInput]
}

input AnswerUncheckedUpdateWithoutUserInput {
  id: IntFieldUpdateOperationsInput
  isRigth: BoolFieldUpdateOperationsInput
}

input AnswerUpdateInput {
  isRigth: BoolFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAnswersInput
}

input AnswerUpdateManyMutationInput {
  isRigth: BoolFieldUpdateOperationsInput
}

input AnswerUpdateManyWithWhereWithoutUserInput {
  data: AnswerUncheckedUpdateManyWithoutAnswersInput!
  where: AnswerScalarWhereInput!
}

input AnswerUpdateManyWithoutUserInput {
  connect: [AnswerWhereUniqueInput]
  connectOrCreate: [AnswerCreateOrConnectWithoutUserInput]
  create: [AnswerCreateWithoutUserInput]
  createMany: AnswerCreateManyUserInputEnvelope
  delete: [AnswerWhereUniqueInput]
  deleteMany: [AnswerScalarWhereInput]
  disconnect: [AnswerWhereUniqueInput]
  set: [AnswerWhereUniqueInput]
  update: [AnswerUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [AnswerUpdateManyWithWhereWithoutUserInput]
  upsert: [AnswerUpsertWithWhereUniqueWithoutUserInput]
}

input AnswerUpdateWithWhereUniqueWithoutUserInput {
  data: AnswerUncheckedUpdateWithoutUserInput!
  where: AnswerWhereUniqueInput!
}

input AnswerUpdateWithoutUserInput {
  isRigth: BoolFieldUpdateOperationsInput
}

input AnswerUpsertWithWhereUniqueWithoutUserInput {
  create: AnswerUncheckedCreateWithoutUserInput!
  update: AnswerUncheckedUpdateWithoutUserInput!
  where: AnswerWhereUniqueInput!
}

input AnswerWhereInput {
  AND: [AnswerWhereInput]
  NOT: [AnswerWhereInput]
  OR: [AnswerWhereInput]
  id: IntFilter
  isRigth: BoolFilter
  user: UserWhereInput
  userId: IntFilter
}

input AnswerWhereUniqueInput {
  id: Int
}

type BatchPayload {
  count: Int!
}

"""BigInt custom scalar type"""
scalar BigInt

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""Date custom scalar type"""
scalar DateTime

"""Decimal custom scalar type"""
scalar Decimal

type Enum {
  fields: [String!]!
  name: String!
}

input EnumQuestionTypeFieldUpdateOperationsInput {
  set: QuestionType
}

input EnumQuestionTypeFilter {
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeFilter
  notIn: [QuestionType]
}

input EnumQuestionTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumQuestionTypeFilter
  _min: NestedEnumQuestionTypeFilter
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeWithAggregatesFilter
  notIn: [QuestionType]
}

type Field {
  create: Boolean!
  editor: Boolean!
  filter: Boolean!
  id: String!
  isId: Boolean!
  kind: KindEnum!
  list: Boolean!
  name: String!
  order: Int!
  read: Boolean!
  relationField: Boolean
  required: Boolean!
  sort: Boolean!
  title: String!
  type: String!
  unique: Boolean!
  update: Boolean!
  upload: Boolean!
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

"""Json custom scalar type"""
scalar Json

enum KindEnum {
  enum
  object
  scalar
}

type Model {
  create: Boolean!
  delete: Boolean!
  displayFields: [String!]!
  fields: [Field!]!
  id: String!
  idField: String!
  name: String!
  update: Boolean!
}

type Mutation {
  createOneAnswer(data: AnswerCreateInput!): Answer!
  createOneQuestion(data: QuestionCreateInput!): Question!
  createOneTest(data: TestCreateInput!): Test!
  createOneUser(data: UserCreateInput!): User!
  deleteManyAnswer(where: AnswerWhereInput): BatchPayload!
  deleteManyQuestion(where: QuestionWhereInput): BatchPayload!
  deleteManyTest(where: TestWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteOneQuestion(where: QuestionWhereUniqueInput!): Question
  deleteOneTest(where: TestWhereUniqueInput!): Test
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateField(data: UpdateFieldInput!, id: String!, modelId: String!): Field!
  updateManyAnswer(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  updateManyQuestion(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  updateManyTest(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateModel(data: UpdateModelInput!, id: String!): Model!
  updateOneAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer!
  updateOneQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question!
  updateOneTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneAnswer(create: AnswerCreateInput!, update: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer!
  upsertOneQuestion(create: QuestionCreateInput!, update: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question!
  upsertOneTest(create: TestCreateInput!, update: TestUpdateInput!, where: TestWhereUniqueInput!): Test!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedEnumQuestionTypeFilter {
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeFilter
  notIn: [QuestionType]
}

input NestedEnumQuestionTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumQuestionTypeFilter
  _min: NestedEnumQuestionTypeFilter
  equals: QuestionType
  in: [QuestionType]
  not: NestedEnumQuestionTypeWithAggregatesFilter
  notIn: [QuestionType]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateAnswer(cursor: AnswerWhereUniqueInput, orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): AggregateAnswer
  aggregateQuestion(cursor: QuestionWhereUniqueInput, orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): AggregateQuestion
  aggregateTest(cursor: TestWhereUniqueInput, orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): AggregateTest
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): AggregateUser
  findFirstAnswer(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum], orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): Answer
  findFirstQuestion(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum], orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): Question
  findFirstTest(cursor: TestWhereUniqueInput, distinct: [TestScalarFieldEnum], orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): Test
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): User
  findManyAnswer(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum], orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): [Answer!]!
  findManyAnswerCount(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum], orderBy: [AnswerOrderByWithRelationInput], skip: Int, take: Int, where: AnswerWhereInput): Int!
  findManyQuestion(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum], orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): [Question!]!
  findManyQuestionCount(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum], orderBy: [QuestionOrderByWithRelationInput], skip: Int, take: Int, where: QuestionWhereInput): Int!
  findManyTest(cursor: TestWhereUniqueInput, distinct: [TestScalarFieldEnum], orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): [Test!]!
  findManyTestCount(cursor: TestWhereUniqueInput, distinct: [TestScalarFieldEnum], orderBy: [TestOrderByWithRelationInput], skip: Int, take: Int, where: TestWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findManyUserCount(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): Int!
  findUniqueAnswer(where: AnswerWhereUniqueInput!): Answer
  findUniqueQuestion(where: QuestionWhereUniqueInput!): Question
  findUniqueTest(where: TestWhereUniqueInput!): Test
  findUniqueUser(where: UserWhereUniqueInput!): User
  getSchema: Schema!
}

enum QueryMode {
  default
  insensitive
}

type Question {
  answer: String
  code: String
  codeArgs: [String!]!
  expectedResult: String
  id: Int!
  options: [String!]!
  parrentTest: Test!
  parrentTestId: Int!
  text: String!
  type: QuestionType!
}

type QuestionAvgAggregateOutputType {
  id: Float
  parrentTestId: Float
}

input QuestionAvgOrderByAggregateInput {
  id: SortOrder
  parrentTestId: SortOrder
}

type QuestionCountAggregateOutputType {
  _all: Int!
  answer: Int!
  code: Int!
  codeArgs: Int!
  expectedResult: Int!
  id: Int!
  options: Int!
  parrentTestId: Int!
  text: Int!
  type: Int!
}

input QuestionCountOrderByAggregateInput {
  answer: SortOrder
  code: SortOrder
  codeArgs: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  options: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  type: SortOrder
}

input QuestionCreateInput {
  answer: String
  code: String
  codeArgs: [String]
  expectedResult: String
  options: [String]
  parrentTest: TestCreateNestedOneWithoutQuestionsInput!
  text: String!
  type: QuestionType!
}

input QuestionCreateManyInput {
  answer: String
  code: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  parrentTestId: Int!
  text: String!
  type: QuestionType!
}

input QuestionCreateManyParrentTestInput {
  answer: String
  code: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  text: String!
  type: QuestionType!
}

input QuestionCreateManyParrentTestInputEnvelope {
  data: QuestionCreateManyParrentTestInput!
  skipDuplicates: Boolean
}

input QuestionCreateManycodeArgsInput {
  set: String!
}

input QuestionCreateManyoptionsInput {
  set: String!
}

input QuestionCreateNestedManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
}

input QuestionCreateOrConnectWithoutParrentTestInput {
  create: QuestionUncheckedCreateWithoutParrentTestInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateWithoutParrentTestInput {
  answer: String
  code: String
  codeArgs: [String]
  expectedResult: String
  options: [String]
  text: String!
  type: QuestionType!
}

input QuestionCreatecodeArgsInput {
  set: String!
}

input QuestionCreateoptionsInput {
  set: String!
}

input QuestionListRelationFilter {
  every: QuestionWhereInput
  none: QuestionWhereInput
  some: QuestionWhereInput
}

type QuestionMaxAggregateOutputType {
  answer: String
  code: String
  expectedResult: String
  id: Int
  parrentTestId: Int
  text: String
  type: QuestionType
}

input QuestionMaxOrderByAggregateInput {
  answer: SortOrder
  code: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  type: SortOrder
}

type QuestionMinAggregateOutputType {
  answer: String
  code: String
  expectedResult: String
  id: Int
  parrentTestId: Int
  text: String
  type: QuestionType
}

input QuestionMinOrderByAggregateInput {
  answer: SortOrder
  code: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  type: SortOrder
}

input QuestionOrderByRelationAggregateInput {
  _count: SortOrder
}

input QuestionOrderByWithAggregationInput {
  _avg: QuestionAvgOrderByAggregateInput
  _count: QuestionCountOrderByAggregateInput
  _max: QuestionMaxOrderByAggregateInput
  _min: QuestionMinOrderByAggregateInput
  _sum: QuestionSumOrderByAggregateInput
  answer: SortOrder
  code: SortOrder
  codeArgs: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  options: SortOrder
  parrentTestId: SortOrder
  text: SortOrder
  type: SortOrder
}

input QuestionOrderByWithRelationInput {
  answer: SortOrder
  code: SortOrder
  codeArgs: SortOrder
  expectedResult: SortOrder
  id: SortOrder
  options: SortOrder
  parrentTest: TestOrderByWithRelationInput
  parrentTestId: SortOrder
  text: SortOrder
  type: SortOrder
}

enum QuestionScalarFieldEnum {
  answer
  code
  codeArgs
  expectedResult
  id
  options
  parrentTestId
  text
  type
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput]
  NOT: [QuestionScalarWhereInput]
  OR: [QuestionScalarWhereInput]
  answer: StringNullableFilter
  code: StringNullableFilter
  codeArgs: StringNullableListFilter
  expectedResult: StringNullableFilter
  id: IntFilter
  options: StringNullableListFilter
  parrentTestId: IntFilter
  text: StringFilter
  type: EnumQuestionTypeFilter
}

input QuestionScalarWhereWithAggregatesInput {
  AND: [QuestionScalarWhereWithAggregatesInput]
  NOT: [QuestionScalarWhereWithAggregatesInput]
  OR: [QuestionScalarWhereWithAggregatesInput]
  answer: StringNullableWithAggregatesFilter
  code: StringNullableWithAggregatesFilter
  codeArgs: StringNullableListFilter
  expectedResult: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  options: StringNullableListFilter
  parrentTestId: IntWithAggregatesFilter
  text: StringWithAggregatesFilter
  type: EnumQuestionTypeWithAggregatesFilter
}

type QuestionSumAggregateOutputType {
  id: Int
  parrentTestId: Int
}

input QuestionSumOrderByAggregateInput {
  id: SortOrder
  parrentTestId: SortOrder
}

enum QuestionType {
  codeQuestion
  textQuestion
}

input QuestionUncheckedCreateInput {
  answer: String
  code: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  parrentTestId: Int!
  text: String!
  type: QuestionType!
}

input QuestionUncheckedCreateNestedManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
}

input QuestionUncheckedCreateWithoutParrentTestInput {
  answer: String
  code: String
  codeArgs: [String]
  expectedResult: String
  id: Int
  options: [String]
  text: String!
  type: QuestionType!
}

input QuestionUncheckedUpdateInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  parrentTestId: IntFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateManyInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  parrentTestId: IntFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
  delete: [QuestionWhereUniqueInput]
  deleteMany: [QuestionScalarWhereInput]
  disconnect: [QuestionWhereUniqueInput]
  set: [QuestionWhereUniqueInput]
  update: [QuestionUpdateWithWhereUniqueWithoutParrentTestInput]
  updateMany: [QuestionUpdateManyWithWhereWithoutParrentTestInput]
  upsert: [QuestionUpsertWithWhereUniqueWithoutParrentTestInput]
}

input QuestionUncheckedUpdateManyWithoutQuestionsInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUncheckedUpdateWithoutParrentTestInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  parrentTest: TestUpdateOneRequiredWithoutQuestionsInput
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateManyMutationInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdateManyWithWhereWithoutParrentTestInput {
  data: QuestionUncheckedUpdateManyWithoutQuestionsInput!
  where: QuestionScalarWhereInput!
}

input QuestionUpdateManyWithoutParrentTestInput {
  connect: [QuestionWhereUniqueInput]
  connectOrCreate: [QuestionCreateOrConnectWithoutParrentTestInput]
  create: [QuestionCreateWithoutParrentTestInput]
  createMany: QuestionCreateManyParrentTestInputEnvelope
  delete: [QuestionWhereUniqueInput]
  deleteMany: [QuestionScalarWhereInput]
  disconnect: [QuestionWhereUniqueInput]
  set: [QuestionWhereUniqueInput]
  update: [QuestionUpdateWithWhereUniqueWithoutParrentTestInput]
  updateMany: [QuestionUpdateManyWithWhereWithoutParrentTestInput]
  upsert: [QuestionUpsertWithWhereUniqueWithoutParrentTestInput]
}

input QuestionUpdateWithWhereUniqueWithoutParrentTestInput {
  data: QuestionUncheckedUpdateWithoutParrentTestInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpdateWithoutParrentTestInput {
  answer: NullableStringFieldUpdateOperationsInput
  code: NullableStringFieldUpdateOperationsInput
  codeArgs: [String]
  expectedResult: NullableStringFieldUpdateOperationsInput
  options: [String]
  text: StringFieldUpdateOperationsInput
  type: EnumQuestionTypeFieldUpdateOperationsInput
}

input QuestionUpdatecodeArgsInput {
  push: [String]
  set: [String]
}

input QuestionUpdateoptionsInput {
  push: [String]
  set: [String]
}

input QuestionUpsertWithWhereUniqueWithoutParrentTestInput {
  create: QuestionUncheckedCreateWithoutParrentTestInput!
  update: QuestionUncheckedUpdateWithoutParrentTestInput!
  where: QuestionWhereUniqueInput!
}

input QuestionWhereInput {
  AND: [QuestionWhereInput]
  NOT: [QuestionWhereInput]
  OR: [QuestionWhereInput]
  answer: StringNullableFilter
  code: StringNullableFilter
  codeArgs: StringNullableListFilter
  expectedResult: StringNullableFilter
  id: IntFilter
  options: StringNullableListFilter
  parrentTest: TestWhereInput
  parrentTestId: IntFilter
  text: StringFilter
  type: EnumQuestionTypeFilter
}

input QuestionWhereUniqueInput {
  id: Int
}

type Schema {
  enums: [Enum!]!
  models: [Model!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String]
  has: String
  hasEvery: [String]
  hasSome: [String]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

type Test {
  _count: TestCountOutputType
  id: Int!
  name: String!
  questions(cursor: QuestionWhereUniqueInput, distinct: QuestionScalarFieldEnum, orderBy: QuestionOrderByWithRelationInput, skip: Int, take: Int, where: QuestionWhereInput): [Question!]!
}

type TestAvgAggregateOutputType {
  id: Float
}

input TestAvgOrderByAggregateInput {
  id: SortOrder
}

type TestCountAggregateOutputType {
  _all: Int!
  id: Int!
  name: Int!
}

input TestCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type TestCountOutputType {
  questions: Int!
}

input TestCreateInput {
  name: String!
  questions: QuestionCreateNestedManyWithoutParrentTestInput
}

input TestCreateManyInput {
  id: Int
  name: String!
}

input TestCreateNestedOneWithoutQuestionsInput {
  connect: TestWhereUniqueInput
  connectOrCreate: TestCreateOrConnectWithoutQuestionsInput
  create: TestUncheckedCreateWithoutQuestionsInput
}

input TestCreateOrConnectWithoutQuestionsInput {
  create: TestUncheckedCreateWithoutQuestionsInput!
  where: TestWhereUniqueInput!
}

input TestCreateWithoutQuestionsInput {
  name: String!
}

type TestMaxAggregateOutputType {
  id: Int
  name: String
}

input TestMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type TestMinAggregateOutputType {
  id: Int
  name: String
}

input TestMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input TestOrderByWithAggregationInput {
  _avg: TestAvgOrderByAggregateInput
  _count: TestCountOrderByAggregateInput
  _max: TestMaxOrderByAggregateInput
  _min: TestMinOrderByAggregateInput
  _sum: TestSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input TestOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  questions: QuestionOrderByRelationAggregateInput
}

input TestRelationFilter {
  is: TestWhereInput
  isNot: TestWhereInput
}

enum TestScalarFieldEnum {
  id
  name
}

input TestScalarWhereWithAggregatesInput {
  AND: [TestScalarWhereWithAggregatesInput]
  NOT: [TestScalarWhereWithAggregatesInput]
  OR: [TestScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type TestSumAggregateOutputType {
  id: Int
}

input TestSumOrderByAggregateInput {
  id: SortOrder
}

input TestUncheckedCreateInput {
  id: Int
  name: String!
  questions: QuestionUncheckedCreateNestedManyWithoutParrentTestInput
}

input TestUncheckedCreateWithoutQuestionsInput {
  id: Int
  name: String!
}

input TestUncheckedUpdateInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUncheckedUpdateManyWithoutParrentTestInput
}

input TestUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TestUncheckedUpdateWithoutQuestionsInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TestUpdateInput {
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutParrentTestInput
}

input TestUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input TestUpdateOneRequiredWithoutQuestionsInput {
  connect: TestWhereUniqueInput
  connectOrCreate: TestCreateOrConnectWithoutQuestionsInput
  create: TestUncheckedCreateWithoutQuestionsInput
  update: TestUncheckedUpdateWithoutQuestionsInput
  upsert: TestUpsertWithoutQuestionsInput
}

input TestUpdateWithoutQuestionsInput {
  name: StringFieldUpdateOperationsInput
}

input TestUpsertWithoutQuestionsInput {
  create: TestUncheckedCreateWithoutQuestionsInput!
  update: TestUncheckedUpdateWithoutQuestionsInput!
}

input TestWhereInput {
  AND: [TestWhereInput]
  NOT: [TestWhereInput]
  OR: [TestWhereInput]
  id: IntFilter
  name: StringFilter
  questions: QuestionListRelationFilter
}

input TestWhereUniqueInput {
  id: Int
}

input UpdateFieldInput {
  create: Boolean
  editor: Boolean
  filter: Boolean
  id: String
  isId: Boolean
  kind: KindEnum
  list: Boolean
  name: String
  order: Int
  read: Boolean
  relationField: Boolean
  required: Boolean
  sort: Boolean
  title: String
  type: String
  unique: Boolean
  update: Boolean
  upload: Boolean
}

input UpdateModelInput {
  create: Boolean
  delete: Boolean
  displayFields: [String]
  fields: [UpdateFieldInput]
  idField: String
  name: String
  update: Boolean
}

type User {
  _count: UserCountOutputType
  answers(cursor: AnswerWhereUniqueInput, distinct: AnswerScalarFieldEnum, orderBy: AnswerOrderByWithRelationInput, skip: Int, take: Int, where: AnswerWhereInput): [Answer!]!
  id: Int!
  nickname: String!
  phoneNumber: String!
}

type UserAvgAggregateOutputType {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCountAggregateOutputType {
  _all: Int!
  id: Int!
  nickname: Int!
  phoneNumber: Int!
}

input UserCountOrderByAggregateInput {
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

type UserCountOutputType {
  answers: Int!
}

input UserCreateInput {
  answers: AnswerCreateNestedManyWithoutUserInput
  nickname: String!
  phoneNumber: String!
}

input UserCreateManyInput {
  id: Int
  nickname: String!
  phoneNumber: String!
}

input UserCreateNestedOneWithoutAnswersInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAnswersInput
  create: UserUncheckedCreateWithoutAnswersInput
}

input UserCreateOrConnectWithoutAnswersInput {
  create: UserUncheckedCreateWithoutAnswersInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAnswersInput {
  nickname: String!
  phoneNumber: String!
}

type UserMaxAggregateOutputType {
  id: Int
  nickname: String
  phoneNumber: String
}

input UserMaxOrderByAggregateInput {
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

type UserMinAggregateOutputType {
  id: Int
  nickname: String
  phoneNumber: String
}

input UserMinOrderByAggregateInput {
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

input UserOrderByWithRelationInput {
  answers: AnswerOrderByRelationAggregateInput
  id: SortOrder
  nickname: SortOrder
  phoneNumber: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  id
  nickname
  phoneNumber
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  nickname: StringWithAggregatesFilter
  phoneNumber: StringWithAggregatesFilter
}

type UserSumAggregateOutputType {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUncheckedCreateInput {
  answers: AnswerUncheckedCreateNestedManyWithoutUserInput
  id: Int
  nickname: String!
  phoneNumber: String!
}

input UserUncheckedCreateWithoutAnswersInput {
  id: Int
  nickname: String!
  phoneNumber: String!
}

input UserUncheckedUpdateInput {
  answers: AnswerUncheckedUpdateManyWithoutUserInput
  id: IntFieldUpdateOperationsInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutAnswersInput {
  id: IntFieldUpdateOperationsInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpdateInput {
  answers: AnswerUpdateManyWithoutUserInput
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAnswersInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAnswersInput
  create: UserUncheckedCreateWithoutAnswersInput
  update: UserUncheckedUpdateWithoutAnswersInput
  upsert: UserUpsertWithoutAnswersInput
}

input UserUpdateWithoutAnswersInput {
  nickname: StringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutAnswersInput {
  create: UserUncheckedCreateWithoutAnswersInput!
  update: UserUncheckedUpdateWithoutAnswersInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  answers: AnswerListRelationFilter
  id: IntFilter
  nickname: StringFilter
  phoneNumber: StringFilter
}

input UserWhereUniqueInput {
  id: Int
  nickname: String
  phoneNumber: String
}
